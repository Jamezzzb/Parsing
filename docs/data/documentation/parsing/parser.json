{"variants":[{"paths":["\/documentation\/parsing\/parser"],"traits":[{"interfaceLanguage":"swift"}]}],"relationshipsSections":[{"title":"Conforms To","kind":"relationships","type":"conformsTo","identifiers":["doc:\/\/Parsing\/s43ExpressibleByExtendedGraphemeClusterLiteralP","doc:\/\/Parsing\/s26ExpressibleByStringLiteralP","doc:\/\/Parsing\/s33ExpressibleByUnicodeScalarLiteralP"]}],"metadata":{"symbolKind":"struct","title":"Parser","externalID":"s:7Parsing6ParserV","roleHeading":"Structure","modules":[{"name":"Parsing"}],"role":"symbol","navigatorTitle":[{"kind":"identifier","text":"Parser"}],"fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"Parser","kind":"identifier"}]},"schemaVersion":{"minor":3,"major":0,"patch":0},"kind":"symbol","hierarchy":{"paths":[["doc:\/\/Parsing\/documentation\/Parsing"]]},"identifier":{"url":"doc:\/\/Parsing\/documentation\/Parsing\/Parser","interfaceLanguage":"swift"},"sections":[],"topicSections":[{"title":"Initializers","identifiers":["doc:\/\/Parsing\/documentation\/Parsing\/Parser\/init(run:)"]},{"identifiers":["doc:\/\/Parsing\/documentation\/Parsing\/Parser\/run"],"title":"Instance Properties"},{"identifiers":["doc:\/\/Parsing\/documentation\/Parsing\/Parser\/flatMap(_:)","doc:\/\/Parsing\/documentation\/Parsing\/Parser\/map(_:)","doc:\/\/Parsing\/documentation\/Parsing\/Parser\/run(_:)","doc:\/\/Parsing\/documentation\/Parsing\/Parser\/zeroOrMore(separatedBy:)"],"title":"Instance Methods"},{"title":"Type Properties","identifiers":["doc:\/\/Parsing\/documentation\/Parsing\/Parser\/char","doc:\/\/Parsing\/documentation\/Parsing\/Parser\/never","doc:\/\/Parsing\/documentation\/Parsing\/Parser\/oneOrMoreSpaces","doc:\/\/Parsing\/documentation\/Parsing\/Parser\/zeroOrMoreSpaces"]},{"title":"Type Methods","identifiers":["doc:\/\/Parsing\/documentation\/Parsing\/Parser\/always(_:)","doc:\/\/Parsing\/documentation\/Parsing\/Parser\/char(_:)","doc:\/\/Parsing\/documentation\/Parsing\/Parser\/matchingAllCharacters(notIn:)","doc:\/\/Parsing\/documentation\/Parsing\/Parser\/oneOf(_:)","doc:\/\/Parsing\/documentation\/Parsing\/Parser\/prefix(_:)","doc:\/\/Parsing\/documentation\/Parsing\/Parser\/prefix(while:)"]},{"title":"Default Implementations","generated":true,"identifiers":["doc:\/\/Parsing\/documentation\/Parsing\/Parser\/ExpressibleByExtendedGraphemeClusterLiteral-Implementations","doc:\/\/Parsing\/documentation\/Parsing\/Parser\/ExpressibleByStringLiteral-Implementations","doc:\/\/Parsing\/documentation\/Parsing\/Parser\/ExpressibleByUnicodeScalarLiteral-Implementations"]}],"primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"Parser","kind":"identifier"},{"kind":"text","text":"<"},{"text":"Output","kind":"genericParameter"},{"text":">","kind":"text"}],"platforms":["macOS"],"languages":["swift"]}]}],"abstract":[{"type":"text","text":"A generic type for building parsers of ("},{"type":"codeVoice","code":"String"},{"text":") -> ","type":"text"},{"type":"codeVoice","code":"Output"}],"references":{"doc://Parsing/documentation/Parsing/Parser/char(_:)":{"title":"char(_:)","kind":"symbol","type":"topic","identifier":"doc:\/\/Parsing\/documentation\/Parsing\/Parser\/char(_:)","role":"symbol","conformance":{"availabilityPrefix":[{"text":"Available when","type":"text"}],"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"code":"Output","type":"codeVoice"},{"text":" is ","type":"text"},{"type":"codeVoice","code":"Substring"},{"type":"text","text":"."}]},"fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"char","kind":"identifier"},{"text":"(","kind":"text"},{"text":"Character","kind":"typeIdentifier","preciseIdentifier":"s:SJ"},{"text":") -> ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:7Parsing6ParserV","text":"Parser"},{"kind":"text","text":"<"},{"text":"Output","kind":"typeIdentifier"},{"text":">","kind":"text"}],"abstract":[],"url":"\/documentation\/parsing\/parser\/char(_:)"},"doc://Parsing/documentation/Parsing/Parser/zeroOrMore(separatedBy:)":{"role":"symbol","fragments":[{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"zeroOrMore"},{"text":"(","kind":"text"},{"text":"separatedBy","kind":"externalParam"},{"kind":"text","text":": "},{"preciseIdentifier":"s:7Parsing6ParserV","kind":"typeIdentifier","text":"Parser"},{"text":"<","kind":"text"},{"kind":"typeIdentifier","text":"Void","preciseIdentifier":"s:s4Voida"},{"kind":"text","text":">) -> "},{"kind":"typeIdentifier","text":"Parser","preciseIdentifier":"s:7Parsing6ParserV"},{"text":"<[","kind":"text"},{"kind":"typeIdentifier","text":"Output"},{"kind":"text","text":"]>"}],"type":"topic","kind":"symbol","title":"zeroOrMore(separatedBy:)","abstract":[],"url":"\/documentation\/parsing\/parser\/zeroormore(separatedby:)","identifier":"doc:\/\/Parsing\/documentation\/Parsing\/Parser\/zeroOrMore(separatedBy:)"},"doc://Parsing/s33ExpressibleByUnicodeScalarLiteralP":{"title":"Swift.ExpressibleByUnicodeScalarLiteral","type":"unresolvable","identifier":"doc:\/\/Parsing\/s33ExpressibleByUnicodeScalarLiteralP"},"doc://Parsing/documentation/Parsing/Parser/map(_:)":{"fragments":[{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"text":"map","kind":"identifier"},{"text":"<","kind":"text"},{"kind":"genericParameter","text":"B"},{"kind":"text","text":">(("},{"kind":"typeIdentifier","text":"Output"},{"text":") -> ","kind":"text"},{"text":"B","kind":"typeIdentifier"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","preciseIdentifier":"s:7Parsing6ParserV","text":"Parser"},{"text":"<","kind":"text"},{"text":"B","kind":"typeIdentifier"},{"text":">","kind":"text"}],"identifier":"doc:\/\/Parsing\/documentation\/Parsing\/Parser\/map(_:)","title":"map(_:)","type":"topic","url":"\/documentation\/parsing\/parser\/map(_:)","abstract":[],"kind":"symbol","role":"symbol"},"doc://Parsing/documentation/Parsing/Parser/init(run:)":{"kind":"symbol","url":"\/documentation\/parsing\/parser\/init(run:)","abstract":[{"type":"text","text":"Initializes a "},{"code":"Parser","type":"codeVoice"},{"type":"text","text":" with a mutating function on "},{"type":"codeVoice","code":"Substring"},{"type":"text","text":"."}],"title":"init(run:)","type":"topic","identifier":"doc:\/\/Parsing\/documentation\/Parsing\/Parser\/init(run:)","role":"symbol","fragments":[{"text":"init","kind":"identifier"},{"text":"(","kind":"text"},{"kind":"externalParam","text":"run"},{"kind":"text","text":": ("},{"text":"inout","kind":"keyword"},{"text":" ","kind":"text"},{"preciseIdentifier":"s:Ss","text":"Substring","kind":"typeIdentifier"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"Output"},{"text":"?)","kind":"text"}]},"doc://Parsing/documentation/Parsing":{"type":"topic","abstract":[],"role":"collection","title":"Parsing","identifier":"doc:\/\/Parsing\/documentation\/Parsing","kind":"symbol","url":"\/documentation\/parsing"},"doc://Parsing/documentation/Parsing/Parser/zeroOrMoreSpaces":{"conformance":{"conformancePrefix":[{"type":"text","text":"Conforms when"}],"availabilityPrefix":[{"text":"Available when","type":"text"}],"constraints":[{"code":"Output","type":"codeVoice"},{"text":" is ","type":"text"},{"type":"codeVoice","code":"()"},{"text":".","type":"text"}]},"kind":"symbol","url":"\/documentation\/parsing\/parser\/zeroormorespaces","abstract":[],"title":"zeroOrMoreSpaces","type":"topic","identifier":"doc:\/\/Parsing\/documentation\/Parsing\/Parser\/zeroOrMoreSpaces","role":"symbol","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"text":"let","kind":"keyword"},{"text":" ","kind":"text"},{"text":"zeroOrMoreSpaces","kind":"identifier"},{"kind":"text","text":": "},{"preciseIdentifier":"s:7Parsing6ParserV","kind":"typeIdentifier","text":"Parser"},{"text":"<()>","kind":"text"}]},"doc://Parsing/documentation/Parsing/Parser/ExpressibleByExtendedGraphemeClusterLiteral-Implementations":{"role":"collectionGroup","identifier":"doc:\/\/Parsing\/documentation\/Parsing\/Parser\/ExpressibleByExtendedGraphemeClusterLiteral-Implementations","type":"topic","abstract":[],"url":"\/documentation\/parsing\/parser\/expressiblebyextendedgraphemeclusterliteral-implementations","kind":"article","title":"ExpressibleByExtendedGraphemeClusterLiteral Implementations"},"doc://Parsing/documentation/Parsing/Parser/oneOrMoreSpaces":{"kind":"symbol","type":"topic","abstract":[],"role":"symbol","title":"oneOrMoreSpaces","identifier":"doc:\/\/Parsing\/documentation\/Parsing\/Parser\/oneOrMoreSpaces","fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"let","kind":"keyword"},{"kind":"text","text":" "},{"text":"oneOrMoreSpaces","kind":"identifier"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","text":"Parser","preciseIdentifier":"s:7Parsing6ParserV"},{"text":"<()>","kind":"text"}],"url":"\/documentation\/parsing\/parser\/oneormorespaces","conformance":{"availabilityPrefix":[{"type":"text","text":"Available when"}],"constraints":[{"type":"codeVoice","code":"Output"},{"text":" is ","type":"text"},{"code":"()","type":"codeVoice"},{"type":"text","text":"."}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]}},"doc://Parsing/documentation/Parsing/Parser/flatMap(_:)":{"title":"flatMap(_:)","identifier":"doc:\/\/Parsing\/documentation\/Parsing\/Parser\/flatMap(_:)","kind":"symbol","abstract":[],"role":"symbol","url":"\/documentation\/parsing\/parser\/flatmap(_:)","fragments":[{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"text":"flatMap","kind":"identifier"},{"text":"<","kind":"text"},{"kind":"genericParameter","text":"B"},{"text":">((","kind":"text"},{"kind":"typeIdentifier","text":"Output"},{"kind":"text","text":") -> "},{"preciseIdentifier":"s:7Parsing6ParserV","text":"Parser","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"kind":"typeIdentifier","text":"B"},{"text":">) -> ","kind":"text"},{"text":"Parser","kind":"typeIdentifier","preciseIdentifier":"s:7Parsing6ParserV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"B"},{"text":">","kind":"text"}],"type":"topic"},"doc://Parsing/documentation/Parsing/Parser/prefix(while:)":{"role":"symbol","kind":"symbol","fragments":[{"text":"static","kind":"keyword"},{"kind":"text","text":" "},{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"prefix","kind":"identifier"},{"kind":"text","text":"("},{"text":"while","kind":"externalParam"},{"kind":"text","text":": ("},{"text":"Character","preciseIdentifier":"s:SJ","kind":"typeIdentifier"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","preciseIdentifier":"s:Sb","text":"Bool"},{"text":") -> ","kind":"text"},{"preciseIdentifier":"s:7Parsing6ParserV","text":"Parser","kind":"typeIdentifier"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Output"},{"text":">","kind":"text"}],"url":"\/documentation\/parsing\/parser\/prefix(while:)","identifier":"doc:\/\/Parsing\/documentation\/Parsing\/Parser\/prefix(while:)","type":"topic","title":"prefix(while:)","abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"Parser"},{"text":" that prefixes until predicate fails.","type":"text"}],"conformance":{"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"code":"Output","type":"codeVoice"},{"text":" is ","type":"text"},{"type":"codeVoice","code":"Substring"},{"text":".","type":"text"}],"availabilityPrefix":[{"type":"text","text":"Available when"}]}},"doc://Parsing/documentation/Parsing/Parser/always(_:)":{"identifier":"doc:\/\/Parsing\/documentation\/Parsing\/Parser\/always(_:)","type":"topic","role":"symbol","fragments":[{"text":"static","kind":"keyword"},{"kind":"text","text":" "},{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"always"},{"text":"<","kind":"text"},{"kind":"genericParameter","text":"A"},{"text":">(","kind":"text"},{"text":"A","kind":"typeIdentifier"},{"kind":"text","text":") -> "},{"preciseIdentifier":"s:7Parsing6ParserV","text":"Parser","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"kind":"typeIdentifier","text":"A"},{"text":">","kind":"text"}],"url":"\/documentation\/parsing\/parser\/always(_:)","kind":"symbol","title":"always(_:)","abstract":[{"text":"A parser that always ","type":"text"},{"code":"succeeds","type":"codeVoice"},{"text":", useful when combined with ","type":"text"},{"code":"flatMap(_:)","type":"codeVoice"},{"text":".","type":"text"}]},"doc://Parsing/documentation/Parsing/Parser/ExpressibleByUnicodeScalarLiteral-Implementations":{"kind":"article","type":"topic","abstract":[],"role":"collectionGroup","identifier":"doc:\/\/Parsing\/documentation\/Parsing\/Parser\/ExpressibleByUnicodeScalarLiteral-Implementations","title":"ExpressibleByUnicodeScalarLiteral Implementations","url":"\/documentation\/parsing\/parser\/expressiblebyunicodescalarliteral-implementations"},"doc://Parsing/documentation/Parsing/Parser/run(_:)":{"abstract":[{"text":"Attempts to parse ","type":"text"},{"type":"codeVoice","code":"Output"},{"type":"text","text":" from provided input string."}],"kind":"symbol","type":"topic","role":"symbol","identifier":"doc:\/\/Parsing\/documentation\/Parsing\/Parser\/run(_:)","fragments":[{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"text":"run","kind":"identifier"},{"kind":"text","text":"("},{"kind":"keyword","text":"consuming"},{"text":" ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:SS","text":"String"},{"text":") -> (match","kind":"text"},{"text":": ","kind":"text"},{"text":"Output","kind":"typeIdentifier"},{"text":"?, rest","kind":"text"},{"kind":"text","text":": "},{"text":"Substring","kind":"typeIdentifier","preciseIdentifier":"s:Ss"},{"kind":"text","text":")"}],"url":"\/documentation\/parsing\/parser\/run(_:)","title":"run(_:)"},"doc://Parsing/documentation/Parsing/Parser/ExpressibleByStringLiteral-Implementations":{"kind":"article","title":"ExpressibleByStringLiteral Implementations","identifier":"doc:\/\/Parsing\/documentation\/Parsing\/Parser\/ExpressibleByStringLiteral-Implementations","url":"\/documentation\/parsing\/parser\/expressiblebystringliteral-implementations","abstract":[],"type":"topic","role":"collectionGroup"},"doc://Parsing/documentation/Parsing/Parser/never":{"kind":"symbol","type":"topic","abstract":[{"type":"text","text":"A parser that always fails, useful when combined with "},{"type":"codeVoice","code":"flatMap(_:)"},{"type":"text","text":"."}],"role":"symbol","identifier":"doc:\/\/Parsing\/documentation\/Parsing\/Parser\/never","title":"never","fragments":[{"kind":"keyword","text":"static"},{"text":" ","kind":"text"},{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"never","kind":"identifier"},{"kind":"text","text":": "},{"preciseIdentifier":"s:7Parsing6ParserV","text":"Parser","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"kind":"typeIdentifier","text":"Output"},{"text":">","kind":"text"}],"url":"\/documentation\/parsing\/parser\/never"},"doc://Parsing/documentation/Parsing/Parser/char":{"kind":"symbol","title":"char","abstract":[],"type":"topic","role":"symbol","url":"\/documentation\/parsing\/parser\/char","identifier":"doc:\/\/Parsing\/documentation\/Parsing\/Parser\/char","conformance":{"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"code":"Output","type":"codeVoice"},{"type":"text","text":" is "},{"code":"Character","type":"codeVoice"},{"type":"text","text":"."}]},"fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"let","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"char"},{"kind":"text","text":": "},{"preciseIdentifier":"s:7Parsing6ParserV","text":"Parser","kind":"typeIdentifier"},{"kind":"text","text":"<"},{"text":"Character","kind":"typeIdentifier","preciseIdentifier":"s:SJ"},{"kind":"text","text":">"}]},"doc://Parsing/documentation/Parsing/Parser":{"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"Parser","kind":"identifier"}],"identifier":"doc:\/\/Parsing\/documentation\/Parsing\/Parser","role":"symbol","title":"Parser","navigatorTitle":[{"kind":"identifier","text":"Parser"}],"abstract":[{"text":"A generic type for building parsers of (","type":"text"},{"type":"codeVoice","code":"String"},{"text":") -> ","type":"text"},{"type":"codeVoice","code":"Output"}],"type":"topic","url":"\/documentation\/parsing\/parser","kind":"symbol"},"doc://Parsing/s26ExpressibleByStringLiteralP":{"identifier":"doc:\/\/Parsing\/s26ExpressibleByStringLiteralP","type":"unresolvable","title":"Swift.ExpressibleByStringLiteral"},"doc://Parsing/s43ExpressibleByExtendedGraphemeClusterLiteralP":{"identifier":"doc:\/\/Parsing\/s43ExpressibleByExtendedGraphemeClusterLiteralP","type":"unresolvable","title":"Swift.ExpressibleByExtendedGraphemeClusterLiteral"},"doc://Parsing/documentation/Parsing/Parser/prefix(_:)":{"type":"topic","url":"\/documentation\/parsing\/parser\/prefix(_:)","kind":"symbol","title":"prefix(_:)","identifier":"doc:\/\/Parsing\/documentation\/Parsing\/Parser\/prefix(_:)","abstract":[{"text":"parses literal off beginning of string","type":"text"}],"role":"symbol","conformance":{"constraints":[{"type":"codeVoice","code":"Output"},{"type":"text","text":" is "},{"code":"()","type":"codeVoice"},{"text":".","type":"text"}],"availabilityPrefix":[{"text":"Available when","type":"text"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"text":"prefix","kind":"identifier"},{"kind":"text","text":"("},{"preciseIdentifier":"s:SS","text":"String","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"preciseIdentifier":"s:7Parsing6ParserV","text":"Parser","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"kind":"typeIdentifier","text":"Output"},{"text":">","kind":"text"}]},"doc://Parsing/documentation/Parsing/Parser/oneOf(_:)":{"kind":"symbol","type":"topic","abstract":[{"type":"text","text":"returns the first parser that succeeds"}],"role":"symbol","identifier":"doc:\/\/Parsing\/documentation\/Parsing\/Parser\/oneOf(_:)","title":"oneOf(_:)","fragments":[{"kind":"keyword","text":"static"},{"text":" ","kind":"text"},{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"text":"oneOf","kind":"identifier"},{"text":"<","kind":"text"},{"text":"A","kind":"genericParameter"},{"text":">(","kind":"text"},{"kind":"typeIdentifier","text":"Parser","preciseIdentifier":"s:7Parsing6ParserV"},{"text":"<","kind":"text"},{"kind":"typeIdentifier","text":"A"},{"text":">...) -> ","kind":"text"},{"text":"Parser","kind":"typeIdentifier","preciseIdentifier":"s:7Parsing6ParserV"},{"text":"<","kind":"text"},{"kind":"typeIdentifier","text":"A"},{"text":">","kind":"text"}],"url":"\/documentation\/parsing\/parser\/oneof(_:)"},"doc://Parsing/documentation/Parsing/Parser/run":{"kind":"symbol","type":"topic","abstract":[{"text":"Called inside of ","type":"text"},{"type":"codeVoice","code":"run(_:)"},{"type":"text","text":"."}],"role":"symbol","title":"run","identifier":"doc:\/\/Parsing\/documentation\/Parsing\/Parser\/run","fragments":[{"text":"let","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"run"},{"text":": (","kind":"text"},{"kind":"keyword","text":"inout"},{"text":" ","kind":"text"},{"text":"Substring","kind":"typeIdentifier","preciseIdentifier":"s:Ss"},{"text":") -> ","kind":"text"},{"text":"Output","kind":"typeIdentifier"},{"kind":"text","text":"?"}],"url":"\/documentation\/parsing\/parser\/run"},"doc://Parsing/documentation/Parsing/Parser/matchingAllCharacters(notIn:)":{"fragments":[{"kind":"keyword","text":"static"},{"text":" ","kind":"text"},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"text":"matchingAllCharacters","kind":"identifier"},{"text":"(","kind":"text"},{"text":"notIn","kind":"externalParam"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:Sh","kind":"typeIdentifier","text":"Set"},{"kind":"text","text":"<"},{"preciseIdentifier":"s:SJ","text":"Character","kind":"typeIdentifier"},{"kind":"text","text":">) -> "},{"kind":"typeIdentifier","preciseIdentifier":"s:7Parsing6ParserV","text":"Parser"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Output"},{"kind":"text","text":">"}],"abstract":[{"text":"A ","type":"text"},{"code":"Parser","type":"codeVoice"},{"text":" that prefixes while encountered characters not contained in given set.","type":"text"}],"url":"\/documentation\/parsing\/parser\/matchingallcharacters(notin:)","identifier":"doc:\/\/Parsing\/documentation\/Parsing\/Parser\/matchingAllCharacters(notIn:)","conformance":{"conformancePrefix":[{"type":"text","text":"Conforms when"}],"constraints":[{"type":"codeVoice","code":"Output"},{"type":"text","text":" is "},{"type":"codeVoice","code":"Substring"},{"type":"text","text":"."}],"availabilityPrefix":[{"text":"Available when","type":"text"}]},"role":"symbol","type":"topic","kind":"symbol","title":"matchingAllCharacters(notIn:)"}}}